# header names of the full SLiM output file
SECTION_HEADERS <- c("Populations", "Mutations", "Individuals", "Genomes")

#' Parse the population section of the SLiM file into a data frame.
#'
#' @param slim_file SLiM text output file.
read_populations <- function(slim_file) {
    read_section_data(slim_file, "Populations") %>%
        read.table(text = ., col.names = c("pop_id", "pop_size", "sex")) %>%
        as_tibble
}


#' Parse the mutation section of the SLiM file into a data frame.
#'
#' @param slim_file SLiM text output file.
#' @param mut_type Mutation type id (m0, m1, etc.).
#' @param pop_origin Population of origin.
#' @param gen_origin Generation of origin.
read_mutations <- function(slim_file, mut_type = "", pop_origin = "", gen_origin = 0) {
    # read the mutation section lines and filter those mutations
    # that match the given pop. origin and mutation type
    lines <-
        read_section_data(slim_file, "Mutations") %>%
        str_subset(str_c(pop_origin, " \\d+ \\d+$")) %>%
        str_subset(str_c("^\\d+ \\d+ ", mut_type))

    # convert the filtered mutation lines into a tibble
    lines %>%
        read.table(text = .,
                   col.names = c("mut_id", "run_id", "mut_type",
                               "pos", "s", "h", "pop_origin",
                               "gen_origin", "count")) %>%
        filter(gen_origin >= gen_origin )  %>%
        as_tibble
}


#' Parse the genome section of the SLiM file into a data frame.
#'
#' @param slim_file SLiM text output file.
#' @param pop_origin Population of origin.
read_genomes <- function(slim_file, pop_origin = "") {
    # read the genomes section and filter for genomes belonging
    # to the given population
    lines <-
        read_section_data(slim_file, "Genomes") %>%
        str_subset(str_c("^", pop_origin))

    # split each row into three parts - genome ID, auto/sex chromosome
    # and a string with mutation IDs and convert this to a 3 column tibble
    lines %>%
        str_split(" ", 3, simplify = TRUE) %>%
        as_tibble %>%  # convert matrix into tibble
        select(genome_id = V1, chrom_type = V2, mutations = V3) %>%
        mutate(mutations = str_split(mutations, " ")) %>%
        unnest %>%
        mutate(mut_id = as.integer(mutations)) %>%
        select(-mutations)
}


#' Read SLiM output file generated by the sim.outputFull() method.
#'
#' @param slim_file SLiM text output file.
read_slim_file <- function(slim_file) {
    readLines(slim_file)
}


#' Read the positions of the SLiM output file section headers
#' used to break up the whole file into individual chunks
#' (population description, mutations, individuals and genomes).
#'
#' @param slim_file SLiM text output file.
read_section_delims <- function(slim_file) {
    # get positions of the section headers
    section_pos <- c(which(slim_file %in% str_c(SECTION_HEADERS, ":")),
                     length(slim_file) + 1)

    # put information about starts/ends of individuals section
    # into a data frame
    tibble(section = SECTION_HEADERS,
           start = section_pos[-length(section_pos)] + 1,
           end = section_pos[-1] - 1)
}


#' Get the subset of SLiM output file contents for a given section.
#'
#' @param slim_file SLiM text output file.
#' @param section_name Section of the output file.
read_section_data <- function(slim_file, section_name) {
    if (!section_name %in% SECTION_HEADERS)
        stop("Invalid SLiM output section specified!")

    delims <- read_section_delims(slim_file)
    pos_in_file <- filter(delims, section == section_name)

    slim_file[pos_in_file$start : pos_in_file$end]
}


#' Parse the individual section of the SLiM file into a data frame.
read_individuals <- function(slim_file, p = "") {
    read_section_data(slim_file, "Individuals") %>%
        read.table(text = ., col.names = c("indiv_id", "sex",
                                       "genome1_id","genome2_id")) %>%
        as_tibble %>%
        filter(str_detect(indiv_id, str_c("^", p)))
}


#' Convert SLiM individual ID into genome IDs.
get_genome_ids <- function(indiv_id) {
    # split string such as "p3:i0" into "p3:" and "0"
    split_id <- str_split(indiv_id, "i", simplify = TRUE)

    # save both parts to separate variables
    pop_id <- split_id[, 1]
    indiv_no <- split_id[, 2] %>% as.integer

    # use those variables to construct
    str_c(pop_id, c(2 * indiv_no, 2 * indiv_no + 1))
}


#' Calculate the total multiplicative genetic load in a given individual based
#' on a specified dominance.
calculate_indiv_load <- function(indiv_id, muts_per_genome) {
    # get IDs of both genomes of this individual
    genome_ids <- get_genome_ids(indiv_id)

    load_per_locus <-
        filter(muts_per_genome, genome_id %in% genome_ids) %>%
        group_by(mut_id, s, h) %>%
        summarize(count = n()) %>%
        mutate(fitness = ifelse(count == 1, h, 1) * (-s) * count)

    1 - exp(-sum(load_per_locus$fitness))
}
